# 浅谈 Svelte

两个月前 [Svelte](https://svelte.dev) 发布了一次大版本更新（Svelte 3），Svelte 3 相对之前的版本更加成熟，引入了一种新的响应式声明语法，减少用户编写组件所需的样本代码(boilerplate)，并且更换了 LOGO。本文希望通过一个简单的事例，初步分析一下 Svelte 这个框架是怎么运转的

## 一个简单的例子

在继续之前考虑一个简单的需求：

实现一个简单的加法计算器，页面由两个 input 和一个用于展示计算结果的模块，大致就是下面这个样子：

![](https://22infinite-cdn.oss-cn-shenzhen.aliyuncs.com/post/svelte-prototype.png)

用 React 实现如下

```jsx
import React from 'react';

class App extends React.Component {
  state = {
    a: 0,
    b: 0,
  }

  handleChange = name => event => {
    this.setState({
      [name]: parseInt(event.target.value, 10) || 0,
    })
  }

  render () {
    const { a, b } = this.state;

    return (
      <div>
        <input type="number" onChange={this.handleChange('a')}/>
        <input type="number" onChange={this.handleChange('b')}/>
        <p>
          <span>{a}</span>
          +
      <span>{b}</span>
          =
          <span>{a + b}</span>
        </p>
      </div>
    )
  }
}
```

这时你会想，这么简单的功能，有必要用 React 吗，然后你又用原生写了一遍

```javascript
const state = {
  a: 0,
  b: 0,
};
const $root = document.createElement('div');
const $input1 = document.createElement('input');
$input1.type = 'number';
const $input2 = document.createElement('input');
$input2.type = 'number';
const $p = document.createElement('p');

$root.appendChild($input1);
$root.appendChild($input2);
$root.appendChild($p);

const update = () => {
  const { a, b } = this.state;

  $p.innerHTML = `<span>${a}</span>+<span>${b}</span>=<span>${a + b}</span>`;
};

$input1.addEventListener('input', event => {
  state.a = parseInt(event.value, 10) || 0;

  update();
});

$input2.addEventListener('input', event => {
  state.b = parseInt(event.value, 10) || 0;

  update();
});

update();
```

这段代码还原了前端开发的本来样子，但是目前看来和 React 的实现相比有一个比较明显的缺陷，那就是每次 `update` 的时候 `<p>` 的子节点都会全部重新渲染，而 React 是能够找到真正需要更新的节点的，为此我们需要修改一下代码来实现更准确的更新

```javascript
const state = {
  a: 0,
  b: 0,
};
const $root = document.createElement('div');
const $input1 = document.createElement('input');
$input1.type = 'number';
const $input2 = document.createElement('input');
$input2.type = 'number';
const $p = document.createElement('p');
const $span1 = document.createElement('span');
$span1.textContent = state.a;
const $span2 = document.createElement('span');
$span2.textContent = state.b;
const $span3 = document.createElement('span');
$span3.textContent = state.a + state.b;
const $text1 = document.createTextNode('+');
const $text2 = document.createTextNode('=');

$root.appendChild($input1);
$root.appendChild($input2);
$root.appendChild($p);

$p.appendChild($span1);
$p.appendChild($text1);
$p.appendChild($span2);
$p.appendChild($text2);
$p.appendChild($span3);

let change = {};

const update = () => {
  const { a, b } = this.state;

  if (change.a) {
    $span1.textContent = a;
    $span3.textContent = a + b;
  }

  if (change.b) {
    $span2.textContent = b;
    $span3.textContent = a + b;
  }

  change = {}
};

$input1.addEventListener('input', event => {
  state.a = parseInt(event.value, 10) || 0;

  change.a = true;

  update();
});

$input2.addEventListener('input', event => {
  state.b = parseInt(event.value, 10) || 0;

  change.b = true;

  update();
});
```

这是用「原生」JS 实现精确更新的最简单的方式，但是很多人看到这里会觉得这也太麻烦了吧，所以如今流行的前端框架就是通过 Virtual DOM 等抽象试图减轻开发者的负担，但是减轻的负担往往是需要用户来买单（更大的代码体积，更差的兼容性）

而 Svelte 的思路和别的框架不同，Svelte 想的是，如果开发者觉得麻烦，那「我」帮你们生成不就好了?

## Svelte 怎么做

说到前端框架，虽然未必都用过，但是谁能说出 React、Vue、Angular 这几个响当当的名字，这些流行的前端框架通过 MV* 模式将数据、逻辑以及输出结果展示进行分离，使得应用代码更加容易设计、开发、管理。

Svelte 并不是传统意义上的框架因为它不运行在浏览器，而是作为一个编译器对你的代码进行加工，使得最终的代码能够获得 MV* 的能力，第一次看见 Svelte 时我深深意识到自己思维的局限性，原来前端框架还可以不在「前端」

说回刚才的例子，在 Svelte 中，你只需要这样写

```html
<script>
	let a = 1;
	let b = 2;
</script>

<input type="number" bind:value={a}>
<input type="number" bind:value={b}>

<p>{a} + {b} = {a + b}</p>
```

再看看经过 Svelte 编译后的代码

```javascript
/* App.svelte generated by Svelte v3.6.10 */
import {
	SvelteComponent,
	append,
	attr,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text,
	to_number
} from "svelte/internal";

function create_fragment(ctx) {
	var input0, t0, input1, t1, p, t2, t3, t4, t5, t6_value = ctx.a + ctx.b, t6, dispose;

	return {
		c() {
			input0 = element("input");
			t0 = space();
			input1 = element("input");
			t1 = space();
			p = element("p");
			t2 = text(ctx.a);
			t3 = text(" + ");
			t4 = text(ctx.b);
			t5 = text(" = ");
			t6 = text(t6_value);
			attr(input0, "type", "number");
			attr(input1, "type", "number");

			dispose = [
				listen(input0, "input", ctx.input0_input_handler),
				listen(input1, "input", ctx.input1_input_handler)
			];
		},

		m(target, anchor) {
			insert(target, input0, anchor);

			input0.value = ctx.a;

			insert(target, t0, anchor);
			insert(target, input1, anchor);

			input1.value = ctx.b;

			insert(target, t1, anchor);
			insert(target, p, anchor);
			append(p, t2);
			append(p, t3);
			append(p, t4);
			append(p, t5);
			append(p, t6);
		},

		p(changed, ctx) {
			if (changed.a) input0.value = ctx.a;
			if (changed.b) input1.value = ctx.b;

			if (changed.a) {
				set_data(t2, ctx.a);
			}

			if (changed.b) {
				set_data(t4, ctx.b);
			}

			if ((changed.a || changed.b) && t6_value !== (t6_value = ctx.a + ctx.b)) {
				set_data(t6, t6_value);
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(input0);
				detach(t0);
				detach(input1);
				detach(t1);
				detach(p);
			}

			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let a = 1;
	let b = 2;

	function input0_input_handler() {
		a = to_number(this.value);
		$$invalidate('a', a);
	}

	function input1_input_handler() {
		b = to_number(this.value);
		$$invalidate('b', b);
	}

	return {
		a,
		b,
		input0_input_handler,
		input1_input_handler
	};
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

export default App;
```

代码非常简单易懂，可以看到最终代码的核心逻辑和我刚才实现的没有很大的差异（因为我是看着它来写的），而且这已经是整个应用的全部代码了

Svelte 从编译的角度减轻了开发者的负担，没有 Virtual DOM 也不用 Object.defineProperty 这种黑魔法，需要开发者写的代码不多，用户也不需要为开发者的开发体验买单

当然，Svelte 目前还在比较初级的阶段，生态和 3 大框架相比还有较大的距离，在前端工程化、大型应用中的表现如何还有待研究

## 拓展阅读

[Rich Harris - Rethinking reactivity](https://www.youtube.com/watch?v=AdNJ3fydeao)

